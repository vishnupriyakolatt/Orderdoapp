{"version":3,"sources":["index.ts"],"names":[],"mappings":";AAGA,oBAAY,aAAa,GAAG,KAAK,GAAG,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AAIjE,eAAO,MAAM,UAAU,EAAE;KACpB,CAAC,IAAI,aAAa,GAAG,MAAM;CAM/B,CAAC;AAOF,wBAAgB,IAAI,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,MAAM,EAAE,OAAO,GAAE,MAAW,EAAE,SAAS,GAAE,aAAwB,GAAG,MAAM,CAatI;AAED,wBAAgB,MAAM,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,MAAM,EAAE,aAAa,GAAE,aAAwB,GAAG,YAAY,CAgB5H;AACD,MAAM,WAAW,YAAY;IACzB,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,EAAE,OAAO,CAAC;CACpB;AA0CD,wBAAgB,IAAI,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,MAAM,EAAE,aAAa,GAAE,aAAwB,GAAG,MAAM,CAMpH;AAOD,wBAAgB,IAAI,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,UAQ1C","file":"index.d.ts","sourcesContent":["import { createHmac, randomBytes } from \"crypto\";\n\nconst IV = randomBytes(16);\n\n/** Supported hash algorithms */\nexport type HashAlgorithm = \"md5\" | \"sha1\" | \"sha256\" | \"sha512\";\n\n/** Crypt algorithms */\n// export type CryptAlgorithms = \"aes-128-gcm\" | \"aes-192-gcm\" | \"aes-256-gcm\";\n\n/** Hash sizes */\nexport const _hashSizes: { [k in HashAlgorithm]: number } = {\n\tmd5: 16,\n\tsha1: 20,\n\tsha256: 32,\n\tsha512: 64,\n};\n\n/**\n * Generate token from Data\n * @param {string|Buffer}\tdata\t- Data to sign. When string, will be encoded as \"utf8\". To use different encoding, insert a buffer instead.\n * @param {string}\tsecret\t- Secret key\n * @param {string}\talgorithm\t- Hash algorithm @default sha256\n */\nexport function sign(\n\tdata: string | Buffer,\n\tsecret: string | Buffer,\n\texpires: number = -1,\n\talgorithm: HashAlgorithm = \"sha512\"\n): Buffer {\n\tif (typeof data === \"string\") data = Buffer.from(data, \"utf8\");\n\tconst hashSize = _hashSizes[algorithm];\n\tconst hashExpSize = hashSize + 8; // Hash & expires size\n\tconst resultBuffer = Buffer.allocUnsafe(hashExpSize + data.length);\n\tresultBuffer.writeDoubleLE(expires, hashSize);\n\tdata.copy(resultBuffer, hashExpSize);\n\t// Hash\n\tconst hashAlg = createHmac(algorithm, secret);\n\thashAlg.update(resultBuffer.slice(hashSize));\n\thashAlg.digest().copy(resultBuffer);\n\treturn resultBuffer;\n}\n\n/** verify and return data */\nexport function verify(\n\tdata: string | Buffer,\n\tsecret: string | Buffer,\n\thashAlgorithm: HashAlgorithm = \"sha512\"\n): verifyResult {\n\tif (typeof data === \"string\") data = Buffer.from(data, \"base64url\");\n\t//* Decode signed data: Buffer.concat([B_ENCODE_TYPE_SIGN, hashAlg.digest(), data]);\n\tvar hashSize = _hashSizes[hashAlgorithm];\n\tvar hash = data.slice(0, hashSize);\n\tconst expires = data.readDoubleLE(hashSize);\n\t//* Check data correct\n\tconst hashAlg = createHmac(hashAlgorithm, secret);\n\thashAlg.update(data.slice(hashSize));\n\tvar resultHash = hashAlg.digest();\n\treturn {\n\t\tisValid: resultHash.compare(hash) === 0,\n\t\texpires: expires,\n\t\tdata: data.slice(hashSize + 8),\n\t};\n}\n\nexport interface verifyResult {\n\tdata: Buffer;\n\texpires: number;\n\tisValid: boolean;\n}\n\n// /**\n//  * Encrypt data\n//  */\n// export function encrypt(\n// \tdata: string | Buffer,\n// \tsecret: string,\n// \thashAlgorithm: HashAlgorithm = \"sha512\",\n// \tcryptAlgorithm: CryptAlgorithms = \"aes-256-gcm\"\n// ) {\n// \tif (typeof data === \"string\") data = Buffer.from(data, \"utf8\");\n// \t// Create hash\n// \tconst hashAlg = createHash(hashAlgorithm);\n// \thashAlg.update(data);\n// \tconst hash = hashAlg.digest();\n// \t// Concat data & hash\n// \tconst b2crypt = Buffer.alloc(data.length + hash.length);\n// \thash.copy(b2crypt, 0);\n// \tdata.copy(b2crypt, hash.length);\n// \t// Crypt all\n// \tconst c = createCipheriv(cryptAlgorithm, secret, IV);\n// \tc.update(b2crypt);\n// \treturn Buffer.concat([IV, c.final(), c.getAuthTag()]);\n// }\n\n// /**\n//  * Decrypt data\n//  * @param {Buffer|base64url_string} data - data to decode. If string and not base64url, convert it to buffer with your logic: like Buffer.from(data, \"Encoding\")\n//  */\n// export function decrypt(\n// \tdata: string | Buffer,\n// \tsecret: string,\n// \thashAlgorithm: HashAlgorithm = \"sha512\",\n// \tcryptAlgorithm: CryptAlgorithms = \"aes-256-gcm\"\n// ) {\n// \t// if (typeof data === \"string\") data = Buffer.from(data, \"base64url\");\n// \t// // Decrypt data\n// \t// const iv = data.slice(0, 16);\n// \t// const c = createCipheriv(cryptAlgorithm, secret, IV);\n// \t// TODO\n// \tthrow new Error(\"Unimplemented!\");\n// }\n\n//* HASH PASSWORDS\nexport function hash(\n\tdata: string | Buffer,\n\tsecret: string | Buffer,\n\thashAlgorithm: HashAlgorithm = \"sha512\"\n): Buffer {\n\tif (typeof data === \"string\") data = Buffer.from(data, \"utf8\");\n\tconst hashAlg = createHmac(hashAlgorithm, secret);\n\thashAlg.update(data);\n\treturn hashAlg.digest();\n}\n\n\n/**\n * CRC1 method\n * Enables to check strings & buffers using only 1 Byte.\n * Useful to check ids against *Writing Errors*\n * If you need security, use \"sign\" instead\n */\nexport function crc1(input: string | Buffer) {\n\tif (typeof input === 'string') input = Buffer.from(input);\n\tvar accumulation = 0;\n\tfor (let i = 0, len = input.length; i < len; ++i) {\n\t\taccumulation += input[i];\n\t}\n\treturn accumulation & 255;\n}"]}